#!/usr/bin/env python3
"""
Vibe Coding Project Setup Script

This script automates the initial setup phase for a "Vibe Coding" project, creating the necessary
directory structure and populating it with template files to prepare for development using LLMs like
Gemini and Claude in the Cursor IDE.

The script creates:
- A root project directory (with sanitized name for filesystem compatibility)
- memory-bank/ directory with template markdown files
- .cursor/rules/ directory with MDC-formatted rule files
"""

from pathlib import Path
import sys
import re
import argparse
import os

# Version information
VERSION = "1.1.0"

# ===================================================================================
# Template Definitions (Optional Additions)
# ===================================================================================

def get_laravel_supabase_setup_instructions():
    """Returns the content for the Laravel + Supabase setup instruction file."""
    # Simplified instruction as requested
    return """---
description: Guide for setting up Laravel project
type: Default
---

Use docker for installing laravel project.
"""

# Defines optional additional templates (applied *after* base structure)
# User selects by number (1-based index corresponding to list index + 1)
ADDITIONAL_TEMPLATES = [
    {
        "id": "laravel-supabase",
        "name": "Add: Laravel with Supabase Auth Instructions",
        "directories": [], # No *additional* directories beyond base
        "files": {
            # Adds specific setup instructions for Laravel + Supabase
            ".cursor/rules/laravel-supabase-setup.mdc": get_laravel_supabase_setup_instructions,
        }
    },
    # Add more templates here in the future
]

# ===================================================================================
# Template Constants (Base Structure)
# ===================================================================================

# Template for 01-product-design-document.md (previously product-requirements-document.md)
PRODUCT_REQUIREMENTS_TEMPLATE = """# Product Requirements Document (PRD)

**Project:** {project_name}

*Initial Description Provided During Setup:*
> {project_description}

---
**Instructions for Generation:**

Use an LLM (like Gemini 2.5 Pro) to flesh out this PRD based on your initial description. Provide the initial description and ask the LLM to expand on it, defining core features, target audience, user stories, and any non-functional requirements.

**Example Prompt for LLM:**
"Based on the following initial description for my project '{project_name}', please help me create a detailed Product Requirements Document (PRD).
Initial Description: '{project_description}'
Please include sections for: Overview, Core Features (with brief descriptions), Target Audience, User Stories (at least 3-5 examples), and Non-Functional Requirements (e.g., performance, security)."

*(Delete these instructions once the PRD is generated)*
---
"""

# Template for 02-tech-stack.md
TECH_STACK_TEMPLATE = """# Tech Stack Recommendations

**Project:** {project_name}

---
**Instructions for Generation:**

Use an LLM (like Gemini 2.5 Pro) to recommend a suitable tech stack for your project. Provide the LLM with the content of your `01-product-design-document.md`. Ask for the simplest yet most robust stack possible for your requirements.

**Example Prompt for LLM:**
"Based on the attached Product Requirements Document (`01-product-design-document.md`) for my project '{project_name}', please recommend the simplest yet most robust tech stack. Consider frontend, backend (if applicable), database, and any key libraries or frameworks. Explain the reasoning behind your choices."

*(Attach or paste the content of `01-product-design-document.md` when prompting. Delete these instructions once the tech stack is defined)*
---
"""

# Template for 03-implementation-plan.md
IMPLEMENTATION_PLAN_TEMPLATE = """# Implementation Plan

**Project:** {project_name}

---
**Instructions for Generation:**

Use an LLM (like Gemini 2.5 Pro) to create a detailed, step-by-step implementation plan. Provide the LLM with both your `01-product-design-document.md` and `02-tech-stack.md`. Each step should be small, specific, testable, and focus on building the core functionality first.

**Example Prompt for LLM:**
"Based on the attached Product Requirements Document (`01-product-design-document.md`) and Tech Stack (`02-tech-stack.md`) for my project '{project_name}', please generate a detailed, step-by-step implementation plan. Break down the core functionality into small, manageable steps. For each step, describe the task and suggest a simple test to verify its completion. Focus on the Minimum Viable Product (MVP) first."

*(Attach or paste the content of both `.md` files when prompting. Delete these instructions once the plan is generated)*
---
"""

# Template for 04-progress.md
PROGRESS_TEMPLATE = """# Project Progress Tracker

**Project:** {project_name}

## Completed Steps

"""

# Template for 05-architecture.md
ARCHITECTURE_TEMPLATE = """# System Architecture Overview

**Project:** {project_name}

## File/Component Index

## Data Structures / Schema

## Diagrams (Optional)

"""

# Templates for Cursor rule files (MDC format)
CURSOR_RULES_ARCHITECTURE = """---
description: Enforce reading architecture documentation
type: Always
---

Always read memory-bank/05-architecture.md before writing any code. Include entire database schema if applicable.
"""

CURSOR_RULES_REQUIREMENTS = """---
description: Enforce reading requirements documentation
type: Always
---

Always read memory-bank/01-product-design-document.md before writing any code.
"""

CURSOR_RULES_UPDATE_ARCHITECTURE = """---
description: Remember to update architecture documentation
type: Default
---

After adding a major feature or completing a milestone, update memory-bank/05-architecture.md.
"""

CURSOR_RULES_UPDATE_PROGRESS = """---
description: Remember to update progress tracker
type: Default
---

After completing a milestone or implementation step, update memory-bank/04-progress.md with details about what was accomplished.
"""

CURSOR_RULES_VALIDATION_WORKFLOW = """---
description: Implementation step validation workflow
type: Always
---

For each implementation step from the implementation plan:

1. Complete the implementation for the current step only
2. Ask the user to validate and confirm before proceeding to the next step
3. Once validated:
   - Update memory-bank/04-progress.md with details about the completed step
   - Update memory-bank/05-architecture.md if the step involved new components or structures
   - Commit changes to git with a descriptive message
4. Only after validation, proceed to the next implementation step
"""

CURSOR_RULES_MODULARITY = """---
description: Enforce code modularity
type: Default
---

Emphasize modularity (multiple files) and avoid creating monolithic files.
"""

CURSOR_RULES_README = """---
description: Keep README.md updated after major steps
type: Default
---

After completing each major implementation step, update the project's README.md with:

1. What the project does (with latest features added)
2. Why these features are useful
3. How users can get started with these features
4. Any updated usage examples
5. Current project status

The README should be the single source of truth for new users discovering your project. Keep it concise, accurate, and up-to-date. Consider adding:

- A clear description of what the project does
- Installation and setup instructions
- Basic usage examples
- Technology stack overview
- Current status/roadmap
- Contributors section

Place README.md in the repository root for maximum visibility.
"""

# Post-execution instructions (Simplified)
POST_EXECUTION_INSTRUCTIONS = """âœ… Project '{project_name}' structure created successfully at: {directory_name}/

Next Steps:

1.  Navigate to the project: `cd {directory_name}`
2.  Open in Cursor: `cursor .`
3.  Generate content for `memory-bank/` files (start with 01-...). 
4.  Review/customize rules in `.cursor/rules/`.
5.  Follow `03-implementation-plan.md` and coding workflow.

Happy Vibe Coding! ðŸš€
"""

# ===================================================================================
# Helper Functions
# ===================================================================================

def sanitize_project_name(name):
    """
    Convert project name to a filesystem-friendly format.
    
    Args:
        name (str): Original project name
        
    Returns:
        str: Sanitized name (spaces converted to hyphens, special chars removed)
    """
    # Replace spaces with hyphens and remove any special characters
    sanitized = re.sub(r'[^\w\-]', '', name.replace(' ', '-'))
    return sanitized.lower()

def get_project_name():
    """
    Prompt user for project name and validate the input.
    
    Returns:
        tuple: (original_project_name, sanitized_project_name)
    """
    while True:
        project_name = input("Enter project name: ").strip()
        
        if not project_name:
            print("Error: Project name cannot be empty.")
            continue
        
        sanitized_name = sanitize_project_name(project_name)
        
        # If name was modified during sanitization, inform the user
        if sanitized_name != project_name:
            print(f"Note: Project name will be sanitized to '{sanitized_name}' for directory creation.")
            
        return project_name, sanitized_name

def get_project_description():
    """
    Prompt user for project description.
    
    Returns:
        str: Project description entered by the user
    """
    return input("Enter a brief project description: ").strip()

def select_additional_templates(available_templates):
    """Prompts the user to select optional additional templates."""
    if not available_templates:
        return [] # No templates to choose from

    print("\nThe following optional templates can add specific instructions to the base setup:")
    for i, template in enumerate(available_templates):
        print(f"  {i + 1}. {template.get('name', f'Unnamed Template {i+1}')}")

    while True:
        prompt = "Select template numbers to apply (comma-separated, e.g., 1), or press Enter to continue with base structure only: "
        selection = input(prompt).strip()

        if not selection:
            return [] # User pressed Enter

        selected_indices = set()
        selected_templates_list = []
        valid_selection = True
        parts = [part.strip() for part in selection.split(',') if part.strip()]

        if not parts:
             print("Error: Empty selection entered. Please enter numbers or press Enter.")
             continue

        for part in parts:
            try:
                index = int(part) - 1 # User enters 1-based, convert to 0-based
                if 0 <= index < len(available_templates):
                    if index not in selected_indices:
                        selected_indices.add(index)
                        selected_templates_list.append(available_templates[index])
                    else:
                        print(f"Warning: Template {part} selected multiple times. Including it once.")
                else:
                    print(f"Error: Invalid selection '{part}'. Please enter numbers from 1 to {len(available_templates)}.")
                    valid_selection = False
                    break
            except ValueError:
                print(f"Error: Invalid input '{part}'. Please enter numbers only.")
                valid_selection = False
                break

        if valid_selection:
            # Sort based on original index to maintain consistency if needed later
            selected_templates_list.sort(key=lambda t: available_templates.index(t))
            return selected_templates_list

# ===================================================================================
# File and Directory Creation Functions
# ===================================================================================

def create_project_directory(sanitized_project_name):
    """
    Create the root project directory. Exit if it already exists.
    
    Args:
        sanitized_project_name (str): Sanitized name for the project directory
        
    Returns:
        Path: Path object for the created directory
        
    Exits:
        If directory already exists or there's an error in creation
    """
    project_path = Path.cwd() / sanitized_project_name
    
    if project_path.exists():
        print(f"Error: Directory '{sanitized_project_name}' already exists. Please choose a different name.")
        sys.exit(1)
    
    try:
        project_path.mkdir()
        print(f"Created project directory: {project_path}")
        return project_path
    except Exception as e:
        print(f"Error creating project directory: {e}")
        sys.exit(1)

def create_subdirectories(project_path):
    """
    Create required subdirectories within the project directory.
    
    Args:
        project_path (Path): Path to the project root directory
        
    Returns:
        tuple: (memory_bank_path, cursor_path)
        
    Exits:
        If there's an error in creating subdirectories
    """
    memory_bank_path = project_path / "memory-bank"
    cursor_path = project_path / ".cursor"
    
    try:
        memory_bank_path.mkdir(parents=True, exist_ok=True)
        cursor_path.mkdir(parents=True, exist_ok=True)
        print(f"Created subdirectory: {memory_bank_path}")
        print(f"Created subdirectory: {cursor_path}")
        return memory_bank_path, cursor_path
    except Exception as e:
        print(f"Error creating subdirectories: {e}")
        sys.exit(1)

def create_memory_bank_files(memory_bank_path, original_project_name, project_description):
    """
    Create and populate the required files in the memory-bank directory.
    Files are created with numeric prefixes to indicate reading order.
    
    Args:
        memory_bank_path (Path): Path object for the memory-bank directory
        original_project_name (str): Original human-readable project name for file content
        project_description (str): Description of the project
        
    Returns:
        list: List of Path objects for the created files
    """
    # Define the files to create and their content templates, with order prefixes
    # The order is defined by the position in this ordered dictionary
    files_to_create = {
        "01-product-design-document.md": PRODUCT_REQUIREMENTS_TEMPLATE,
        "02-tech-stack.md": TECH_STACK_TEMPLATE,
        "03-implementation-plan.md": IMPLEMENTATION_PLAN_TEMPLATE,
        "04-progress.md": PROGRESS_TEMPLATE,
        "05-architecture.md": ARCHITECTURE_TEMPLATE
    }
    
    created_files = []
    
    # Create each file with the appropriate content
    for filename, template in files_to_create.items():
        file_path = memory_bank_path / filename
        
        try:
            # Format the template with project details, using the original name for content
            content = template.format(
                project_name=original_project_name,
                project_description=project_description
            )
            
            # Write the content to the file
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(content)
                
            print(f"Created file: {file_path}")
            created_files.append(file_path)
        except Exception as e:
            print(f"Error creating {filename}: {e}")
            
    return created_files

def create_cursor_rules_files(cursor_path):
    """
    Create and populate the .cursor/rules directory with MDC rule files.
    
    Args:
        cursor_path (Path): Path object for the .cursor directory
        
    Returns:
        list: List of Path objects for the created files
    """
    # Create rules directory if it doesn't exist
    rules_dir = cursor_path / "rules"
    if not rules_dir.exists():
        rules_dir.mkdir(exist_ok=True)
    
    # Define the rules to create
    rules_to_create = {
        "architecture.mdc": CURSOR_RULES_ARCHITECTURE,
        "requirements.mdc": CURSOR_RULES_REQUIREMENTS,
        "update_architecture.mdc": CURSOR_RULES_UPDATE_ARCHITECTURE,
        "update_progress.mdc": CURSOR_RULES_UPDATE_PROGRESS,
        "validation_workflow.mdc": CURSOR_RULES_VALIDATION_WORKFLOW,
        "modularity.mdc": CURSOR_RULES_MODULARITY,
        "readme.mdc": CURSOR_RULES_README
    }
    
    created_files = []
    
    # Create each rule file with the appropriate content
    for filename, content in rules_to_create.items():
        file_path = rules_dir / filename
        
        try:
            # Write the content to the file
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(content)
                
            print(f"Created rule file: {file_path}")
            created_files.append(file_path)
        except Exception as e:
            print(f"Error creating {filename}: {e}")
            
    return created_files

def create_base_readme(project_path, project_name, project_description):
    """Creates a basic README.md file in the project root."""
    readme_content = f"""# {project_name}

{project_description}

This project was initialized using the Vibe Coding Setup script.

## Getting Started

1.  Open this folder in Cursor.
2.  Generate content for the files in `memory-bank/` following the instructions within them.
3.  Start development following the `memory-bank/03-implementation-plan.md`.
"""
    readme_path = project_path / "README.md"
    try:
        with open(readme_path, 'w', encoding='utf-8') as f:
            f.write(readme_content)
        print(f"Created file: {readme_path}")
    except Exception as e:
        print(f"Error creating README.md: {e}")

def create_base_gitignore(project_path):
    """Creates a basic .gitignore file in the project root."""
    gitignore_content = """# Python
__pycache__/
*.py[cod]
*$py.class

# Environments
.env
.venv
venv/
ENV/
env/

# IDE specific
.vscode/
.idea/
*.swp
*.swo
.DS_Store
"""
    gitignore_path = project_path / ".gitignore"
    try:
        with open(gitignore_path, 'w', encoding='utf-8') as f:
            f.write(gitignore_content)
        print(f"Created file: {gitignore_path}")
    except Exception as e:
        print(f"Error creating .gitignore: {e}")

# ===================================================================================
# Core Generation Logic
# ===================================================================================

def generate_base_structure(root_dir_name, project_name, project_description):
    """Creates the entire base project structure and returns the root path."""
    # Create root directory
    project_path = create_project_directory(root_dir_name)
    if not project_path:
        # Error handled in create_project_directory, which exits
        return None 

    # Create standard subdirectories
    memory_bank_path, cursor_path = create_subdirectories(project_path)
    if not memory_bank_path or not cursor_path:
        # Error handled in create_subdirectories, which exits
        return None

    # Create standard files
    create_memory_bank_files(memory_bank_path, project_name, project_description)
    create_cursor_rules_files(cursor_path)
    create_base_readme(project_path, project_name, project_description)
    create_base_gitignore(project_path)
    
    return project_path

def apply_additional_templates(selected_templates, root_dir):
    """Applies the selected additional templates to the project structure."""
    if not selected_templates:
        return

    print("\nApplying selected templates...")
    for template in selected_templates:
        template_name = template.get('name', template.get('id', 'Unknown Template'))
        print(f"  Applying: {template_name}")

        # Create additional directories specified by the template
        for dir_path_str in template.get("directories", []):
            full_dir_path = root_dir / dir_path_str
            try:
                os.makedirs(full_dir_path, exist_ok=True)
                print(f"    Ensured directory exists: {full_dir_path}")
            except Exception as e:
                print(f"    Error creating directory {full_dir_path}: {e}")
                # Decide whether to continue or stop if a directory fails
                continue 

        # Create additional files specified by the template
        for file_path_str, content_source in template.get("files", {}).items():
            full_file_path = root_dir / file_path_str
            try:
                # Ensure parent directory exists
                parent_dir = os.path.dirname(full_file_path)
                if parent_dir:
                    os.makedirs(parent_dir, exist_ok=True)

                # Get content
                content = ""
                if callable(content_source):
                    content = content_source() # Call the function to get content
                elif isinstance(content_source, str):
                    content = content_source # Use the string directly
                else:
                    print(f"    Warning: Unsupported content source type for {file_path_str} in template {template_name}")
                    continue

                # Write file
                with open(full_file_path, 'w', encoding='utf-8') as f:
                    f.write(content)
                print(f"    Created file: {full_file_path}")

            except Exception as e:
                print(f"    Error creating file {full_file_path}: {e}")
                # Decide whether to continue or stop if a file fails
                continue

# ===================================================================================
# Post Execution
# ===================================================================================

def print_post_execution_instructions(original_project_name, sanitized_project_name):
    """
    Format and print simplified post-execution instructions to the user.
    
    Args:
        original_project_name (str): Original human-readable name of the project
        sanitized_project_name (str): Sanitized name of the project used for directory
    """
    # Format the instructions with the project name and directory name
    instructions = POST_EXECUTION_INSTRUCTIONS.format(
        project_name=original_project_name,
        directory_name=sanitized_project_name
    )
    
    # Print the formatted instructions directly, without extra separators
    print(f"\n{instructions}")

# ===================================================================================
# Main Execution
# ===================================================================================

def main():
    """Main function that orchestrates the project setup process."""
    # Parse command line arguments
    parser = argparse.ArgumentParser(description="Vibe Coding Project Setup Script")
    parser.add_argument("--version", action="store_true", help="Print version information")
    args = parser.parse_args()
    
    # Handle version flag
    if args.version:
        print(f"Vibe Coding Setup v{VERSION}")
        return
    
    print("Vibe Coding Project Setup Script")
    
    # Get user input
    original_project_name, sanitized_project_name = get_project_name()
    project_description = get_project_description()
    
    # Ask user to select optional templates
    selected_templates = select_additional_templates(ADDITIONAL_TEMPLATES)
    
    # Create BASE directory structure and standard files
    project_path = generate_base_structure(sanitized_project_name, original_project_name, project_description)
    
    # Check if base structure generation was successful 
    if not project_path:
         print("Failed to create base project structure. Exiting.")
         sys.exit(1)
    
    # Apply selected additional templates if any were chosen
    if selected_templates:
       apply_additional_templates(selected_templates, project_path)
    
    # Print summary
    print(f"\nProject Setup Summary:")
    print(f"  Project Name: {original_project_name}")
    print(f"  Directory Name: {sanitized_project_name}")
    print(f"  Project Path: {project_path}")
    if selected_templates:
        print("  Additional Templates Applied:")
        for template in selected_templates:
            print(f"    - {template.get('name', template.get('id'))}")
    else:
        print("  Additional Templates Applied: None")
    
    # Print post-execution instructions
    print_post_execution_instructions(original_project_name, sanitized_project_name)

if __name__ == "__main__":
    main() 